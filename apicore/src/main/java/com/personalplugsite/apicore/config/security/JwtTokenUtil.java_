package com.personalplugsite.apicore.config.security;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.SignatureException;
import io.jsonwebtoken.UnsupportedJwtException;

import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import com.dxc.digital.fingerprint.data.entities.Employee;

import java.util.Base64;
import java.util.Date;

import static java.lang.String.format;

@Component
@RequiredArgsConstructor
@Slf4j
public class JwtTokenUtil {

	private static String apiJwtIssuer;
	private static String oktaClientId;
	private static String oktaIntrospectionEndpoint;
	private static boolean validateOktaJwtWithIntrospectionPoint;

	@Value("${efp.security.jwt.api.issuer}")
	public void setApiJwtIssuer(String apiJwtIssuer) {
		JwtTokenUtil.apiJwtIssuer = apiJwtIssuer;
	}

	@Value("${efp.security.jwt.okta.clientId}")
	public void setOktaClientId(String oktaClientId) {
		JwtTokenUtil.oktaClientId = oktaClientId;
	}

	@Value("${efp.security.jwt.okta.introspection_endpoint}")
	public void setOktaIntrospectionEndpoint(String oktaIntrospectionEndpoint) {
		JwtTokenUtil.oktaIntrospectionEndpoint = oktaIntrospectionEndpoint;
	}

	@Value("${efp.security.jwt.okta.validate_jwt}")
	public void setValidateOktaJwtWithIntrospectionPoint(boolean validateOktaJwtWithIntrospectionPoint) {
		JwtTokenUtil.validateOktaJwtWithIntrospectionPoint = validateOktaJwtWithIntrospectionPoint;
	}

	@Value("${efp.security.jwt.api.password}")
	private String apiJwtPassword;

	@Value("${efp.security.jwt.api.jwtExpirationMs}")
	private Long apiJwtExpirationMs;

	private static String microsoftGraphURL;
	private static String microsoftClientId;
	private static String microsoftClientSecret;
	private static String microsoftScope;

	@Value("${microsoft.graph.url}")
	public void setMicrosoftGraphURL(String microsoftGraphURL) {
		JwtTokenUtil.microsoftGraphURL = microsoftGraphURL;
	}

	@Value("${microsoft.graph.clientId}")
	public void setMicrosoftClientId(String microsoftClientId) {
		JwtTokenUtil.microsoftClientId = microsoftClientId;
	}

	@Value("${microsoft.graph.client.secret}")
	public void setMicrosoftClientSecret(String microsoftClientSecret) {
		JwtTokenUtil.microsoftClientSecret = microsoftClientSecret;
	}

	@Value("${microsoft.graph.scope}")
	public void setMicrosoftScope(String microsoftScope) {
		JwtTokenUtil.microsoftScope = microsoftScope;
	}

	/**
	 * Sends request to Okta servers to validate token
	 * 
	 * @param token
	 * @return whether token is valid or not. If a token is expired, it is
	 *         considered invalid.
	 */
	public static boolean isOktaJWTTokenValid(String token) {
		if (validateOktaJwtWithIntrospectionPoint) {
			log.debug("Validating OKTA token.");
			HttpHeaders headers = new HttpHeaders();
			headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

			MultiValueMap<String, String> map = new LinkedMultiValueMap<String, String>();
			map.add("client_id", oktaClientId);
			map.add("token", token);

			HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<MultiValueMap<String, String>>(map,
					headers);

			log.info("About to send request to introspection endpoint.");

			RestTemplate restTemplate = new RestTemplate();

			ResponseEntity<String> response = restTemplate.postForEntity(oktaIntrospectionEndpoint, request,
					String.class);

			log.info("POST request to introspection endpoint sent.");

			log.info("Got OKTA validation response: ");
			log.info(response.getBody());

			JSONObject oktaValidationStatus = new JSONObject(response.getBody());
			return oktaValidationStatus.getBoolean("active");
		} else {
			return true;
		}
	}

	public static JSONObject getOktaJWTTokenPayload(String token) {
		String[] chunks = token.split("\\.");

		Base64.Decoder decoder = Base64.getDecoder();

		return new JSONObject(new String(decoder.decode(chunks[1])));
	}

	public String generateAccessToken(Employee person, Integer local) {
		return Jwts.builder().setSubject(format("%s", person.getUsername())).setIssuer(apiJwtIssuer)
				.setIssuedAt(new Date())
				.setExpiration(new Date(System.currentTimeMillis() + apiJwtExpirationMs))
				.claim("localTimeOffset", local)
				.signWith(SignatureAlgorithm.HS512, apiJwtPassword).compact();
	}

	public String getUsername(String token) {
		Claims claims = Jwts.parser().setSigningKey(apiJwtPassword).parseClaimsJws(token).getBody();

		return claims.getSubject();
	}

	public Date getExpirationDate(String token) {
		Claims claims = Jwts.parser().setSigningKey(apiJwtPassword).parseClaimsJws(token).getBody();

		return claims.getExpiration();
	}

	public Integer getLocale(String token) {
		Claims claims = Jwts.parser().setSigningKey(apiJwtPassword).parseClaimsJws(token).getBody();

		return (Integer) claims.get("localTimeOffset");
	}

	public boolean validate(String token) {
		try {
			Jwts.parser().setSigningKey(apiJwtPassword).parseClaimsJws(token);
			return true;
		} catch (SignatureException ex) {
			log.error("Invalid JWT signature - {}", ex.getMessage());
		} catch (MalformedJwtException ex) {
			log.error("Invalid JWT token - {}", ex.getMessage());
		} catch (ExpiredJwtException ex) {
			log.error("Expired JWT token - {}", ex.getMessage());
		} catch (UnsupportedJwtException ex) {
			log.error("Unsupported JWT token - {}", ex.getMessage());
		} catch (IllegalArgumentException ex) {
			log.error("JWT claims string is empty - {}", ex.getMessage());
		}
		return false;
	}

	/**
	 * Obtains an Authorization token from Microsoft Graph
	 *
	 * @return Authorization token
	 */
	public static String getMicrosoftAuthorizationToken() {
		HttpHeaders httpHeaders = new HttpHeaders();
		httpHeaders.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

		MultiValueMap<String, String> map = new LinkedMultiValueMap<String, String>();
		map.add("grant_type", "client_credentials");
		map.add("client_secret", microsoftClientSecret);
		map.add("client_id", microsoftClientId);
		map.add("scope", microsoftScope);

		HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<MultiValueMap<String, String>>(map,
				httpHeaders);
		RestTemplate restTemplate = new RestTemplate();
		ResponseEntity<String> response = restTemplate.postForEntity(microsoftGraphURL, request, String.class);

		JSONObject accessToken = new JSONObject(response.getBody());
		return accessToken.getString("access_token");
	}

}